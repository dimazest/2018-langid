package TweetProcessing;

# Elizabeth Blair
# Last Edited: 4/7/14
# 4/7/14:	Created (Copied elements from generateOffsets.pl)

use strict;
use warnings;
use v5.10;

use utf8;

# A set of operations related to working with and transforming tweet data (raw data in the
# format generated by tweetPull.rb)

my $oddSymbols = 'ツ•😕😟😑😛😬😴😮😯😀😗😧😙😦\p{Other_Symbol}';

# assembleTweet()
# Input: input file handle
# Output: metadata string, tweet string
# Description: Pull the next tweet from the given file and return both the metadata line and the
#		actual tweet, with original formatting. The end of the tweet must be denoted by
#		a line containing only <ENDOFTWEET>, and the first line must contain metadata.
#		This is the format given by tweetPull.rb.
#		Return undef if the data is unavailable (end of file, no content, etc.).
sub assembleTweet
{
	my $fileHan = shift;
	my $meta = (!eof($fileHan)) ? <$fileHan> : undef;
	chomp $meta;
	my @tweetParts;
	while(!eof($fileHan))
	{
		my $line = <$fileHan>;
		chomp $line;
		if ($line eq '<ENDOFTWEET>') { last; }
		push(@tweetParts,$line);
	}
	my $tweet = (@tweetParts) ? join("\n",@tweetParts) : undef;
	return $meta,$tweet;
}

# genOffsets()
# Input: tweet string, reference to array of tokens
# Output: Array of references to two-element arrays (start and end offsets)
# Description: Find and return the start and end character offsets of each token in the tweet.
#		The offsets begin at 0, and a one-character token will have the same start and end.
#		Base the offsets on the original text - tokens containing &, <, >, or odd Unicode
#		symbols are handled as if they are in original Twitter format. Return the offsets
#		as an array of two-element array references containing the start and end offsets
#		of each token in the order that they were provided.
sub genOffsets
{
	my ($tweet,$tokenRef) = @_;
	my @tokens = @{$tokenRef};

	my @return;
	my $offset = 0;
	for (my $i = 0; $i < scalar(@tokens); $i++)
	{
		my ($tokenstart,$tokenend);
        
        $tokens[$i] =~ s/&/&amp\;/g;
		$tokens[$i] =~ s/\</&lt\;/g;
		$tokens[$i] =~ s/\>/&gt\;/g;

		if ($tokens[$i] =~ /\{symbol\}/)
		{	# Odd unicode symbol adjustment for tokenized version {symbol}
			my $symCount = scalar(split('}',$tokens[$i]));

			my $substr = substr($tweet,$offset);
			my ($toNextSym) = ($substr =~ /^([^$oddSymbols])[$oddSymbols]/);
			unless($toNextSym) { $toNextSym = ''; }
			$tokenstart = $offset + (length($toNextSym));
			$tokenend = $tokenstart+$symCount-1;
			$offset = $tokenend+1;
		}
		else
		{
			if ($tokens[$i] eq "n't" and $offset > 0) { $offset--; }		# Adjust offset back one to catch the n for n't in can't
			$tokenstart = index($tweet,$tokens[$i],$offset);
			$tokenend = $tokenstart + length($tokens[$i])-1;
			$offset = $tokenend+1;
		}

		push(@return,[$tokenstart,$tokenend]);
	}

	return @return;
}



1;
